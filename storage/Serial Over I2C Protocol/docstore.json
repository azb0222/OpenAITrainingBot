{"docstore/metadata": {"8bc8833b-3128-4cdf-87c7-e29a8e785c83": {"doc_hash": "377747e2b6d019fb66fe456c357eca16ed98e6ab619ad3444bb7544730b7cd15"}, "0af62592-6400-41c6-8670-1ab2ecb5aecb": {"doc_hash": "1bdfc5c1493412ac9a117ead07052f25c87b15c39357984850803c5d12ffba36", "ref_doc_id": "8bc8833b-3128-4cdf-87c7-e29a8e785c83"}, "0093c1da-50fa-4923-a372-d85a601fa53e": {"doc_hash": "c6fd144bc5c2920f5034c8fd1a696ff2d3c6f406e0daca7ab626f2f569e3b6f6", "ref_doc_id": "8bc8833b-3128-4cdf-87c7-e29a8e785c83"}, "633dbda5-1da9-43e8-978e-358f6d43f8e6": {"doc_hash": "519a3e2302995d9702605d7170c90c17b8befa4fdf638f14d7f6f72af23cc5e7", "ref_doc_id": "8bc8833b-3128-4cdf-87c7-e29a8e785c83"}, "74f22c44-b6f7-4ba8-a09a-de7df1b745ff": {"doc_hash": "c718b7d0e14ad0cd49213c7a384c4f223ea6e9ed81e79c7e37189ef7af2fe349", "ref_doc_id": "8bc8833b-3128-4cdf-87c7-e29a8e785c83"}, "6cdc1ef4-3090-4242-bad1-04ae41bd9580": {"doc_hash": "18ad18bbb5fab560c2c9d66ba4d115b66f6c4c121d5a86d93f8e9422a5509028", "ref_doc_id": "8bc8833b-3128-4cdf-87c7-e29a8e785c83"}, "288152f8-23ca-4820-afae-a2ae028f8eb5": {"doc_hash": "efda1f7d1c2c5c54dac142f83b05266d4dafcdafc02f079a2c5c9a47121a65fa", "ref_doc_id": "8bc8833b-3128-4cdf-87c7-e29a8e785c83"}}, "docstore/data": {"0af62592-6400-41c6-8670-1ab2ecb5aecb": {"__data__": {"id_": "0af62592-6400-41c6-8670-1ab2ecb5aecb", "embedding": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "8bc8833b-3128-4cdf-87c7-e29a8e785c83", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "377747e2b6d019fb66fe456c357eca16ed98e6ab619ad3444bb7544730b7cd15"}, "3": {"node_id": "0093c1da-50fa-4923-a372-d85a601fa53e", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "c6fd144bc5c2920f5034c8fd1a696ff2d3c6f406e0daca7ab626f2f569e3b6f6"}}, "hash": "1bdfc5c1493412ac9a117ead07052f25c87b15c39357984850803c5d12ffba36", "text": "Serial-Over-I2C Protocol\n\nUnlike many fixed-length and register-based I2C protocols, the Notecard defines a variable-length, serial-over-I2C protocol that allows developers to handle JSON requests and responses in a similar manner as a direct Serial connection. The recommended way to use this protocol is with one of our firmware libraries in the Blues Inc. GitHub organization.\n\nThe Notecard operates the serial-over-I2C protocol at roughly 100kHz, in chunks of no more than 255 bytes, with a minimum 1ms delay between transactions.\n\nNote\n\nIn the following illustrations the host MCU acts as the I2C primary, and the Notecard acts as the I2C secondary device. By default, the Notecard responds to the 7-bit address (0x17), although this can be reconfigured in the Notecard settings, using the card.io command using either the UART or USB interface.\n\nWhat is I2C\n\nIIC, I\u00b2C, and I2C, are synonymous and refer to the inter-integrated circuit bus. The I2C bus allows the different intergrated circuits of a hardware solution to communicate with each other using serialized messages, adhering to the I2C protocol. This guide assumes you have a basic understanding of the general I2C protocol, and will explain how the Blues Serial-over-I2C protocol is built on top of the standard I2C protocol. If you do not have a firm grasp of the I2C protocol, or wish to know more, you may reference the linked PDF guide from Texas Instruments.\n\nTransaction Structure\n\nThe Blues Serial-Over-I2C Protocol uses the basic I2C transaction scheme, but uses a set of ordered transactions to describe and relay serial messages.\n\nOrdered Transaction Listing*\nHandshake (data", "start_char_idx": 0, "end_char_idx": 1651, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "0093c1da-50fa-4923-a372-d85a601fa53e": {"__data__": {"id_": "0093c1da-50fa-4923-a372-d85a601fa53e", "embedding": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "8bc8833b-3128-4cdf-87c7-e29a8e785c83", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "377747e2b6d019fb66fe456c357eca16ed98e6ab619ad3444bb7544730b7cd15"}, "2": {"node_id": "0af62592-6400-41c6-8670-1ab2ecb5aecb", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "1bdfc5c1493412ac9a117ead07052f25c87b15c39357984850803c5d12ffba36"}, "3": {"node_id": "633dbda5-1da9-43e8-978e-358f6d43f8e6", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "519a3e2302995d9702605d7170c90c17b8befa4fdf638f14d7f6f72af23cc5e7"}}, "hash": "c6fd144bc5c2920f5034c8fd1a696ff2d3c6f406e0daca7ab626f2f569e3b6f6", "text": "and relay serial messages.\n\nOrdered Transaction Listing*\nHandshake (data query) - Once, to validate configuration.\nRequest (data write) - Repeatedly, until buffered request is sent.\nPoll (data query) - Poll every ~25ms, until Notecard responds.\nResponse (data read) - Repeatedly, until buffered response is received.\nGo to step 2. Do not return to step 2 before completly reading the response in step 4.\n\n*Transaction captured from the note-arduino library implementation of the Blues Serial-over-I2C protocol.\n\nHandshake\n\nSee data query.\n\nThe \"conversation\" between I2C chips begins, with a handshake (or data query). This satisfies multiple requirements, as well as validates the hardware configuration.\n\nFirst, the I2C write is addressed to a specific value (0x17 by default). If the Notecard is configured with the correct address it will ACK, thus validating the address. After the address, the host MCU will the send subsequent byte parameters, which are immediately followed by a read request. Then the Notecard responds, which indicates it received and understood the parameters, and was also able to generate a response and send it on the bus. If the host MCU understands this response, then the hardware is appropriately configured. Furthermore, this provides the opportunity to the Notecard to indicate its readiness based upon whether or not it has buffered bytes to send to the host MCU (zero buffered bytes is expected).\n\nRequest\n\nSee data write.\n\nThe host MCU will craft a JSON request in a local buffer, then send it using data write transactions. These transactions must be broken into chunks (not to exceed 255 bytes), before they are sent across the wire. Once they have been received by the Notecard they will be reconstructed until a newline \\n is sent to complete the", "start_char_idx": 1586, "end_char_idx": 3375, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "633dbda5-1da9-43e8-978e-358f6d43f8e6": {"__data__": {"id_": "633dbda5-1da9-43e8-978e-358f6d43f8e6", "embedding": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "8bc8833b-3128-4cdf-87c7-e29a8e785c83", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "377747e2b6d019fb66fe456c357eca16ed98e6ab619ad3444bb7544730b7cd15"}, "2": {"node_id": "0093c1da-50fa-4923-a372-d85a601fa53e", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "c6fd144bc5c2920f5034c8fd1a696ff2d3c6f406e0daca7ab626f2f569e3b6f6"}, "3": {"node_id": "74f22c44-b6f7-4ba8-a09a-de7df1b745ff", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "c718b7d0e14ad0cd49213c7a384c4f223ea6e9ed81e79c7e37189ef7af2fe349"}}, "hash": "519a3e2302995d9702605d7170c90c17b8befa4fdf638f14d7f6f72af23cc5e7", "text": "Notecard they will be reconstructed until a newline \\n is sent to complete the request.\n\nPoll\n\nSee data query.\n\nWhile the Notecard is reconstructing and processing the JSON request, the host MCU will use a data query to poll the Notecard every ~25ms. Once the Notecard has completed processing the request and prepared a response, it will respond to the query letting the host know it has buffered bytes ready to send.\n\nResponse\n\nSee data read.\n\nFinally, the host MCU will set aside a buffer to receive the Notecard's response, and request the transmission of the response. Now, the response is sent to the host MCU in chunks the size of the buffer or 253 (whichever is smaller).\n\nThese steps are meant to describe a typical request/response transaction between the host MCU and Notecard. It is by no means meant to be an exhaustive resource describing the transactions possible between the host MCU and Notecard. The goal is to provide a sufficient understanding of the communication between the chips, and give you a foundation to view, understand, and possibly create your own Serial-over-I2C transactions.\n\nData Query\n\nIn order to query the Notecard, the host MCU sends a zero length, no buffer, write transaction to the Notecard.\n\nNo Bytes Available\n\nHere, you can see a write transaction to the address 0x17. Then a zero length byte (0x00), indicating that the host is reading data from the Notecard. Then another zero (0x00), which specifies the length of the buffer allocated to a response string.\n\nImmediately following the write transaction, the host sends a read transaction to address 0x17. The Notecard responds with a zero (0x00), indicating it has no bytes available to send. Then another zero (0x00), indicating no bytes were sent in this response.\n\nBytes", "start_char_idx": 3377, "end_char_idx": 5148, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "74f22c44-b6f7-4ba8-a09a-de7df1b745ff": {"__data__": {"id_": "74f22c44-b6f7-4ba8-a09a-de7df1b745ff", "embedding": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "8bc8833b-3128-4cdf-87c7-e29a8e785c83", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "377747e2b6d019fb66fe456c357eca16ed98e6ab619ad3444bb7544730b7cd15"}, "2": {"node_id": "633dbda5-1da9-43e8-978e-358f6d43f8e6", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "519a3e2302995d9702605d7170c90c17b8befa4fdf638f14d7f6f72af23cc5e7"}, "3": {"node_id": "6cdc1ef4-3090-4242-bad1-04ae41bd9580", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "18ad18bbb5fab560c2c9d66ba4d115b66f6c4c121d5a86d93f8e9422a5509028"}}, "hash": "c718b7d0e14ad0cd49213c7a384c4f223ea6e9ed81e79c7e37189ef7af2fe349", "text": "another zero (0x00), indicating no bytes were sent in this response.\n\nBytes Available\n\nAgain, the host MCU sends a zero length, no buffer, write transaction to the Notecard, followed by read transaction. However, in response to the read request, you see the Notecard respond with a four (0x04), indicating it has four bytes available to send. Then another zero (0x00), indicating no bytes were sent during this response.\n\nData Read\n\nResponse String: {}\\r\\n\n\nThe host MCU sends a write transaction to the address 0x17. Then a zero (0x00), indicating it is attempting to read data from the Notecard. Then a four (0x04), informing the Notecard it has allocated a four byte buffer to hold the response string.\n\nImmediately following the write transaction, the host sends a read transaction to address 0x17. Then the Notecard responds with a zero (0x00), indicating it has no more bytes available to send. Then a four (0x04), specifying the length of the following response string. Subsequently, it sends the four bytes of the response string (noted above). Finally, when the host MCU has filled it's buffer, it NAKs the Notecard to inform it to stop sending data, and the transaction is complete.\n\nData Write\n\nRequest String: {\"req\":\"hub.log\",\"text\":\"Hello, World!\"}\\n\n\n \n\nHere, the host MCU sends a write transaction to the address 0x17. Then an integer value of 30 (0x1E), indicating it will attempt to write 30 bytes to the Notecard. Then it proceeds to send the first 30 bytes of the request string.\n\nFollowing the first write transaction, the host sends another write transaction to address 0x17. Then an integer value of 11 (0x0B), which is the length of the remaining characters of the request. Finally, after", "start_char_idx": 5149, "end_char_idx": 6861, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "6cdc1ef4-3090-4242-bad1-04ae41bd9580": {"__data__": {"id_": "6cdc1ef4-3090-4242-bad1-04ae41bd9580", "embedding": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "8bc8833b-3128-4cdf-87c7-e29a8e785c83", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "377747e2b6d019fb66fe456c357eca16ed98e6ab619ad3444bb7544730b7cd15"}, "2": {"node_id": "74f22c44-b6f7-4ba8-a09a-de7df1b745ff", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "c718b7d0e14ad0cd49213c7a384c4f223ea6e9ed81e79c7e37189ef7af2fe349"}, "3": {"node_id": "288152f8-23ca-4820-afae-a2ae028f8eb5", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "efda1f7d1c2c5c54dac142f83b05266d4dafcdafc02f079a2c5c9a47121a65fa"}}, "hash": "18ad18bbb5fab560c2c9d66ba4d115b66f6c4c121d5a86d93f8e9422a5509028", "text": "which is the length of the remaining characters of the request. Finally, after a short delay*, it sends the last 11 bytes of the request string, which includes the newline character (\\n).\n\n* A 20ms delay is commonly used to separate smaller I2C transactions known as \"chunks\", and a 250ms delay is required to separate \"segments\", ~256 byte I2C transactions. These delays ensure the Notecard has the ability to tend to other operations (i.e. managing the cellular connection).\n\nNote\n\nIn the implementation used by this example, the internal buffer allocated to the I2C bus is set at 32 bytes. Therefore, the write request must be broken into two chunks (as shown above). Each chunk is, itself, a complete I2C transaction. Ultimately, these chunks are reassembled by the Notecard, and processed once the newline character (\\n) has been encountered.\n\nTransaction Walkthrough\n\nNow that you have learned about the different parts of a transaction, let's take a look into how a typical transaction can be generated and the flow of the request and response pattern.\n\nBelow is the Arduino code used to create the oscilloscope captures shown and described above:\n\nCOPY\n#include <Notecard.h>\n\nNotecard notecard;\n\nvoid setup() {\n  notecard.begin();\n\n  J *req = notecard.newRequest(\"hub.log\");\n  if (req != NULL) {\n    if (!JAddStringToObject(req, \"text\", \"Hello, World!\")){\n      // Failed to add log string!\n    } else if (!notecard.sendRequest(req)) {\n      // Failed to send request!\n    }\n  }\n}\n\nvoid loop() { }\n\nFirst, focus on the notecard.begin(); statement. The call to", "start_char_idx": 6861, "end_char_idx": 8428, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}, "288152f8-23ca-4820-afae-a2ae028f8eb5": {"__data__": {"id_": "288152f8-23ca-4820-afae-a2ae028f8eb5", "embedding": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "8bc8833b-3128-4cdf-87c7-e29a8e785c83", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "377747e2b6d019fb66fe456c357eca16ed98e6ab619ad3444bb7544730b7cd15"}, "2": {"node_id": "6cdc1ef4-3090-4242-bad1-04ae41bd9580", "node_type": null, "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}, "hash": "18ad18bbb5fab560c2c9d66ba4d115b66f6c4c121d5a86d93f8e9422a5509028"}}, "hash": "efda1f7d1c2c5c54dac142f83b05266d4dafcdafc02f079a2c5c9a47121a65fa", "text": "{ }\n\nFirst, focus on the notecard.begin(); statement. The call to begin() configures the I2C peripheral, and sends an initial data query to the Notecard. The initial query ensures the Notecard is available on the I2C bus, responding, and ready to receive transactions.\n\nAfter the call to begin, a log request is formed. The request is sent using the notecard.sendRequest(req) statement. The call to sendRequest() generates as many data write transactions as are required to send the outbound request.\n\nNote\n\nImportant: Before the host MCU may send a subsequent request to the Notecard, it must wait to receive the complete response for the previous request. It is unsafe to send a second request without waiting for the first to complete.\n\nWhile waiting for the Notecard to process and respond to the request, the host MCU will issue a data query every ~25ms to poll the Notecard.\n\nOnce the request has been processed by the Notecard, then the Notecard will respond to the data query informing the host MCU there are response bytes available.\n\nFinally, the host MCU allocates a buffer and extends a request to receive the response string by issuing as many data read transactions as necessary to receive the incoming response from the Notecard.\n\nAdditional Resources\nTexas Instruments I2C PDF Guide\nNotecard Interface Reference Guide\nChanging the Notecard I2C Address\nCan we improve this page? Send us feedback", "start_char_idx": 8429, "end_char_idx": 9839, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n"}, "__type__": "1"}}, "docstore/ref_doc_info": {"8bc8833b-3128-4cdf-87c7-e29a8e785c83": {"node_ids": ["0af62592-6400-41c6-8670-1ab2ecb5aecb", "0093c1da-50fa-4923-a372-d85a601fa53e", "633dbda5-1da9-43e8-978e-358f6d43f8e6", "74f22c44-b6f7-4ba8-a09a-de7df1b745ff", "6cdc1ef4-3090-4242-bad1-04ae41bd9580", "288152f8-23ca-4820-afae-a2ae028f8eb5"], "metadata": {"title": "", "category": "Serial Over I2C Protocol", "url": "https://dev.blues.io/guides-and-tutorials/notecard-guides/serial-over-i2c-protocol/"}}}}